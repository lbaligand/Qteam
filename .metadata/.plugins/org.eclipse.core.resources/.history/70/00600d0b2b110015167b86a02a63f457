package tangiblegame;

import processing.core.*;
import processing.event.*;
import processing.video.*;

import java.util.Collections;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

@SuppressWarnings("serial")
public class TangibleGame extends PApplet {

	// Parameters for the plate
	int boxLength = 300;
	int boxDepth = 5;

	// Axis angles (X, Z)
	float rx = 0.0f;
	float rz = 0.0f;

	// Rotation speed
	float speed = 1.0f;

	// Ball
	Mover mover;			// MODIF !!!
	int sphereRadius = 15;

	// CylinderMode parameters
	boolean cylinderMode = false;
	boolean isClicked = false;

	// Data visualization surfaces
	int panelHeight;
	PGraphics dataBackGround;
	PGraphics topView;
	PGraphics scoreboard;	//UNIMPLEMENTED
	
	// Tree visualization
	int treeBaseSize;
	PShape tree;
	ArrayList<PVector> trees;
	
	//=================== MODIF ========================== //
	//Global arguments
		PImage img;
		QuadGraph quadGraph = new QuadGraph();
		PGraphics leftImage;
		PGraphics middleImage;
		PGraphics rightImage;
		TwoDThreeD R2D2;
		List<PVector> intersections;
		
		//Global variables to enable drawing the spectra of the Hough transform
		int rDim, phiDim;
		int[] accumulator;
		
		//Arguments for binary & invertedBinary thresholds
		int lowThreshold;
		int highThreshold;
		
		//Arguments for threshold bars
		HScrollbar lowThresholdBar;
		HScrollbar highThresholdBar;
		
		Capture cam;
		// =================================================== //

	public void setup() {
		// Setup
		size(600, 600, P3D);
		stroke(0);

		// Ball
		mover = new Mover(boxDepth, sphereRadius);

		// Panel
		panelHeight = 100;
		dataBackGround = createGraphics(width, panelHeight, P2D);
		topView = createGraphics(8 * panelHeight / 10, 8 * panelHeight / 10,
				P2D);
		scoreboard = createGraphics(8 * panelHeight / 10, 8 * panelHeight / 10,
				P2D);

		// Trees
		treeBaseSize = 20;
		tree = loadShape("simpleTree.obj");
		tree.scale(50);
		trees = new ArrayList<>();
		
		// ====================== MODIF ===================== //
		cam = new Capture(this, 640, 480);
		cam.start();
		leftImage = createGraphics(100, 100);
		middleImage = createGraphics(100, 100);
		rightImage = createGraphics(100, 100);
		R2D2 = new TwoDThreeD(leftImage.width, leftImage.height);
		intersections = new ArrayList<>();
		// =================================================== //
	}

	public void draw() {
		
		// ============================== MODIF ================================== //
		if (cam.available() == true) {
			cam.read();
		}
		img = cam.get();
		PImage sobelResult = sobel(intensityThreshold(blur(HSBThreshold(img))));
		//Left image
		pushMatrix();
		translate(600, 0);
		leftImage.beginDraw();
		leftImage.background(color(0, 0, 0));
		image(img, 0, 0);
		List<PVector> lines = hough(intensityThreshold(sobelResult), 4);
		intersections = getIntersections(lines, img.width, img.height);
		leftImage.endDraw();
		popMatrix();
		
		PVector rotation = getRot(intersections, R2D2);
		rx = rotation.x;
		rz = rotation.y;
		// ====================================================================== //
		
		lights();
		background(141, 182, 205);
		fill(255, 250, 205);
		drawBackGround();
		image(dataBackGround, 0, 500);
		drawTopView();
		image(topView, panelHeight / 10, height - panelHeight + panelHeight
				/ 10);
		drawScoreBoard();
		image(scoreboard, panelHeight, height - panelHeight + panelHeight / 10);
		
		
		fill(0, 100, 0);
		translate(width / 2, height / 2, 0);

		if (!cylinderMode) {
			if (rx > PI / 3) {
				rx = PI / 3;
			} else if (rx < -PI / 3) {
				rx = -PI / 3;
			}
			if (rz > PI / 3) {
				rz = PI / 3;
			} else if (rz < -PI / 3) {
				rz = -PI / 3;
			}
			rotateX(rx);
			rotateZ(rz);
			box(boxLength, boxDepth, boxLength);

			// Draw the ball on the plate
			pushMatrix();
			mover.update(rx, rz);
			mover.checkEdges(boxLength);
			mover.checkCylinderCollision(trees, treeBaseSize, boxDepth); // MODIF
																			// :
																			// cylinders
																			// ->
																			// trees,
																			// cylinderBaseSize
																			// ->
																			// treeBaseSize
			translate(mover.getX(), -(boxDepth / 2 + sphereRadius),
					mover.getZ());
			mover.display();
			popMatrix();

			// Draw all the added trees on the plate
			for (PVector t : trees) {
				pushMatrix();
				rotate(PI);
				translate(-t.x, -boxDepth / 2, t.y);
				shape(tree);
				popMatrix();
				// c.display(p.x, p.y, boxDepth); //MODIF
			}

		} else {
			pushMatrix();
			// Displays the setup for add-cylinder Mode
			rotateX(-PI / 2);
			box(boxLength, boxDepth, boxLength);

			// Displays the ball
			pushMatrix();
			fill(120, 150, 50);
			translate(mover.getX(), -(boxDepth + sphereRadius), mover.getZ());
			mover.display();
			popMatrix();

			// Add trees on the plate
			pushMatrix();

			// Display the moving cylinder
			// c.display(mouseX - (width/2), mouseY - (height/2), boxDepth);
			// //MODIF

			// Display the tree
			pushMatrix();
			rotate(PI);
			translate(-mouseX + (width / 2), -boxDepth / 2, mouseY
					- (height / 2));
			shape(tree);
			popMatrix();
			// If a click occurs, add a new tree on the plate at that position
			// Check if the cylinder is beyond the edges of the plate and
			// if so, do not place it
			if (isClicked) {
				if ((-mouseX + (width / 2) >= (-boxLength / 2 + treeBaseSize / 2))
						&& (-mouseX + (width / 2) <= (boxLength / 2 - treeBaseSize / 2))
						&& (mouseY - (height / 2) <= (boxLength / 2 - treeBaseSize / 2))
						&& (mouseY - (height / 2) >= (-boxLength / 2 + treeBaseSize / 2))) {

					// cylinders.add(new PVector(mouseX - (width/2), mouseY -
					// (height/2))); //MODIF

					trees.add(new PVector(mouseX - width / 2, mouseY - height
							/ 2));
				}
				isClicked = false;
			}
			// Display the added trees on the plate
			for (PVector t : trees) {
				pushMatrix();
				rotate(PI);
				translate(-t.x, -boxDepth / 2, t.y);
				shape(tree);
				popMatrix();
				// c.display(p.x, p.y, boxDepth); //MODIF
			}
			popMatrix();

			popMatrix();
		}

	}

	// To switch to the add-cylinder Mode if the key SHIFT is pressed
	public void keyPressed() {
		if (key == CODED) {
			if (keyCode == SHIFT) {
				// Activate add-cylinder Mode
				cylinderMode = true;
			}
		}
	}

	// To recover from add-cylinder Mode
	public void keyReleased() {
		if (key == CODED) {
			if (keyCode == SHIFT) {
				cylinderMode = false;
			}
		}
	}

	// Tilt the plate around x & z axis if the mouse is Pressed, according to
	// the speed
	// Note: we do not limit the mouseX and mouseY to the display window
	public void mouseDragged() {
		rx = map(mouseY, 0, height, PI / 3, -PI / 3) * speed;
		rz = map(mouseX, 0, width, PI / 3, -PI / 3) * speed;
	}

	// Increment/Decrement the speed of rotation via the wheel
	public void mouseWheel(MouseEvent event) {
		float e = event.getCount();
		if (e > 0) {
			if (speed > 0.2f) {
				speed -= 0.1f;
			}
		} else {
			if (speed < 1.5f) {
				speed += 0.1f;
			}
		}
	}

	// Set the boolean indicator isClicked to true when a click occurs
	public void mouseClicked() {
		isClicked = true;
	}

	public void drawBackGround() {
		dataBackGround.beginDraw();
		dataBackGround.background(255, 250, 205);
		dataBackGround.endDraw();
	}

	public void drawTopView() {
		topView.beginDraw();

		topView.background(0, 130, 0);
		topView.rect(panelHeight / 10, height - panelHeight + panelHeight / 10,
				8 * panelHeight / 10, 8 * panelHeight / 10);

		float ballPanelWidth = map(2 * sphereRadius, 0, boxLength, 0,
				8 * panelHeight / 10);
		float ballPanelX = map(mover.getX(), -boxLength / 2, boxLength / 2, 0,
				8 * panelHeight / 10);
		float ballPanelY = map(mover.getZ(), -boxLength / 2, boxLength / 2, 0,
				8 * panelHeight / 10);
		topView.fill(139, 10, 90);
		topView.ellipse(ballPanelX, ballPanelY, ballPanelWidth, ballPanelWidth);

		for (PVector t : trees) {
			float cylinderPanelX = map(t.x, -boxLength / 2, boxLength / 2, 0,
					8 * panelHeight / 10); // MODIF : CYLINDER -> TREE
			float cylinderPanelY = map(t.y, -boxLength / 2, boxLength / 2, 0,
					8 * panelHeight / 10);
			float cylinderPanelBaseSize = map(2 * treeBaseSize, 0, boxLength,
					0, 8 * panelHeight / 10);
			topView.fill(0, 139, 0);
			topView.ellipse(cylinderPanelX, cylinderPanelY,
					cylinderPanelBaseSize, cylinderPanelBaseSize);
		}

		topView.endDraw();
	}

	public void drawScoreBoard() {
		scoreboard.beginDraw();

		scoreboard.background(141, 182, 205);
		scoreboard.rect(panelHeight, height - panelHeight + panelHeight / 10,
				8 * panelHeight / 10, 8 * panelHeight / 10);

		scoreboard.textSize(7);
		scoreboard.fill(139, 10, 90);
		// Total Score
		scoreboard.text("Total Score :" + mover.getScore(),
				8 * panelHeight / 200, 8 * panelHeight / 50);
		// Current velocity magnitude
		scoreboard.text("Velocity: " + mover.getVelocityMagnitude(),
				8 * panelHeight / 200, 2.5f * 8 * panelHeight / 50);
		// Points achieved in the last hitting event
		scoreboard.text("Last score: " + mover.getLastScore(),
				8 * panelHeight / 200, 4 * 8 * panelHeight / 50);

		scoreboard.endDraw();
	}

	public PImage binaryFilter(PImage img) {
		
		PImage result = createImage(img.width, img.height, RGB);
		
		for (int i = 0; i < img.width * img.height; i++) {
			float currentBrightness = brightness(img.pixels[i]);
			if (currentBrightness > lowThreshold) {
				result.pixels[i] = color(255);
			} else {
				result.pixels[i] = color(0);
			}
		}
		
		return result;
		
	}

	public PImage InvertedBinaryFilter(PImage img) {
		
		PImage result = createImage(img.width, img.height, RGB);
		
		for (int i = 0; i < img.width * img.height; i++) {
			float currentBrightness = brightness(img.pixels[i]);
			if (currentBrightness <= lowThreshold) {
				result.pixels[i] = color(255);
			} else {
				result.pixels[i] = color(0);
			}
		}
		
		return result;
		
	}

	public PImage HSBThreshold(PImage img) {

		// Threshold values (low & high) for hue, saturation & brightness.
		float lowSat = 70;
		float highSat = 255;
		float lowHue = 90;
		float highHue = 140;
		float lowBright = 30;
		float highBright = 180;

		PImage hueMap = createImage(img.width, img.height, HSB);
		for (int i = 0; i < img.width * img.height; i++) {
			float currentBrightness = brightness(img.pixels[i]);
			float currentSat = saturation(img.pixels[i]);
			float currentHue = hue(img.pixels[i]);
			// Threshold
			if (currentBrightness < lowBright || currentBrightness > highBright
					|| currentSat < lowSat || currentSat > highSat
					|| currentHue < lowHue || currentHue > highHue) {
				hueMap.pixels[i] = color(0);
			} else {
				hueMap.pixels[i] = color(255);
			}
		}

		return hueMap;
		
	}

	public PImage convolute(PImage img) {

		float[][] kernel = { { 0, 0, 0 }, { 0, 2, 0 }, { 0, 0, 0 } };
		float[][] kernel2 = { { 0, 1, 0 }, { 1, 0, 1 }, { 0, 1, 0 } };
		float[][] kernel3 = { { 9, 12, 9 }, { 12, 15, 12 }, { 9, 12, 9 } };

		float weight = 1.f;
		int N = kernel3.length;

		PImage result = createImage(img.width, img.height, ALPHA);
		
		for (int x = N / 2; x < img.width - N / 2; x++) {
			for (int y = N / 2; y < img.height - N / 2; y++) {
				for (int i = -N / 2; i <= N / 2; i++) {
					for (int j = -N / 2; j <= N / 2; j++) {
						result.pixels[x + y * img.width] += kernel3[i + (N / 2)][j
								+ (N / 2)]
								* brightness(img.pixels[x + y * img.width + i
										+ j * img.width]);
					}
				}
				result.pixels[x + y * img.width] = color(result.pixels[x + y
						* img.width]
						/ weight);
			}
		}

		return result;
	}

	public PImage blur(PImage img) {

		float[][] blur = { { 1, 1, 1 }, { 1, 1, 1 }, { 1, 1, 1 } };

		float weight = 9.f;
		int N = blur.length;

		PImage result = createImage(img.width, img.height, ALPHA);
		for (int x = N / 2; x < img.width - N / 2; x++) {
			for (int y = N / 2; y < img.height - N / 2; y++) {
				for (int i = -N / 2; i <= N / 2; i++) {
					for (int j = -N / 2; j <= N / 2; j++) {
						result.pixels[x + y * img.width] += blur[i + (N / 2)][j
								+ (N / 2)]
								* brightness(img.pixels[x + y * img.width + i
										+ j * img.width]);
					}
				}
				result.pixels[x + y * img.width] = color(result.pixels[x + y
						* img.width]
						/ weight);
			}
		}

		return result;
		
	}

	public PImage intensityThreshold(PImage img) {

		// Intensity threshold to filter isolated pixels
		int threshold = 128;

		PImage result = createImage(img.width, img.height, HSB);
		
		for (int i = 0; i < img.width * img.height; i++) {
			float currentBrightness = brightness(img.pixels[i]);
			if (currentBrightness >= threshold) {
				result.pixels[i] = color(255);
			} else {
				result.pixels[i] = color(0);
			}
		}

		return result;
		
	}

	public PImage sobel(PImage img) {

		float[][] hKernel = { { 0, 1, 0 }, { 0, 0, 0 }, { 0, -1, 0 } };
		float[][] vKernel = { { 0, 0, 0 }, { 1, 0, -1 }, { 0, 0, 0 } };

		PImage result = createImage(img.width, img.height, ALPHA);

		// clear the image
		for (int i = 0; i < img.width * img.height; i++) {
			result.pixels[i] = color(0);
		}

		float max = 0;
		float[] buffer = new float[img.width * img.height];

		// Double convolution
		int N = hKernel.length;

		for (int x = N / 2; x < img.width - N / 2; x++) {
			for (int y = N / 2; y < img.height - N / 2; y++) {
				float sum_h = 0, sum_v = 0;
				for (int i = -N / 2; i <= N / 2; i++) {
					for (int j = -N / 2; j <= N / 2; j++) {
						sum_h += hKernel[i + (N / 2)][j + (N / 2)]
								* brightness(img.pixels[x + y * img.width + i
										+ j * img.width]);
						sum_v += vKernel[i + (N / 2)][j + (N / 2)]
								* brightness(img.pixels[x + y * img.width + i
										+ j * img.width]);
					}
				}
				buffer[x + y * img.width] = sqrt(pow(sum_h, 2) + pow(sum_v, 2));
				if (sqrt(pow(sum_h, 2) + pow(sum_v, 2)) > max) {
					max = sqrt(pow(sum_h, 2) + pow(sum_v, 2));
				}
			}
		}

		for (int y = 2; y < img.height - 2; y++) { // Skip top and bottom edges
			for (int x = 2; x < img.width - 2; x++) { // Skip left and right
				if (buffer[y * img.width + x] > (int) (max * 0.3f)) {
					result.pixels[y * img.width + x] = color(255);
				} else {
					result.pixels[y * img.width + x] = color(0);
				}
			}
		}
		
		return result;
		
	}

	public ArrayList<PVector> getIntersections(List<PVector> lines, int width, int height) {

		ArrayList<PVector> intersections = new ArrayList<PVector>();

		for (int i = 0; i < lines.size() - 1; i++) {
			PVector line1 = lines.get(i);
			for (int j = i + 1; j < lines.size(); j++) {
				PVector line2 = lines.get(j);

				// compute the intersection and add it to 'intersections'
				float d = cos(line2.y) * sin(line1.y) - cos(line1.y)
						* sin(line2.y);
				float x = (line2.x * sin(line1.y) - line1.x * sin(line2.y)) / d;
				float y = (-line2.x * cos(line1.y) + line1.x * cos(line2.y))
						/ d;

				if(x >= 0 && y >= 0 && x <= width && y <= height) {
					intersections.add(new PVector(x, y));
				}

				// draw the intersection
				fill(255, 128, 0);
				ellipse(x, y, 10, 10);
			}
		}

		return intersections;
	}

	public ArrayList<PVector> hough(PImage edgeImg, int nLines) {

		float discretizationStepsPhi = 0.06f;
		float discretizationStepsR = 2.5f;

		// dimensions of the accumulator
		phiDim = (int) (Math.PI / discretizationStepsPhi);
		rDim = (int) (((edgeImg.width + edgeImg.height) * 2 + 1) / discretizationStepsR);
		// our accumulator (with a 1 pix margin around)
		accumulator = new int[(phiDim + 2) * (rDim + 2)];

		// =============================================================================
		// Pre-compute the sin and cos values : OPTIMIZATION
		float[] tabSin = new float[phiDim];
		float[] tabCos = new float[phiDim];

		float ang = 0;
		float inverseR = 1.f / discretizationStepsR;

		for (int accPhi = 0; accPhi < phiDim; ang += discretizationStepsPhi, accPhi++) {
			tabSin[accPhi] = (float) (sin(ang) * inverseR);
			tabCos[accPhi] = (float) (cos(ang) * inverseR);
		}
		// ==============================================================================

		// Fill the accumulator: on edge points (ie, white pixels of the edge
		// image), store all possible (r, phi) pairs describing lines going
		// through the point.
		for (int y = 0; y < edgeImg.height; y++) {
			for (int x = 0; x < edgeImg.width; x++) {
				if (brightness(edgeImg.pixels[y * edgeImg.width + x]) != 0) {
					for (int phi = 0; phi < phiDim; phi++) {
						float r = (float) (tabCos[phi] * x + tabSin[phi] * y);
						int realR = round(r + (rDim - 1) * 0.5f);
						accumulator[(phi + 1) * (rDim + 2) + realR]++;
					}
				}
			}
		}

		// Only search around lines with more that this amount of votes
		int minVotes = 180;
		
		HoughComparator comparator = new HoughComparator(accumulator);
		
		ArrayList<Integer> bestCandidates = new ArrayList<Integer>();

		for (int i = 0; i < accumulator.length; ++i) {
			if (accumulator[i] > minVotes) {
				bestCandidates.add(i);
			}
		}
		
		// ======================================================================================
		// Local maxima : OPTIMIZATION
		
		// size of the region we search for a local maximum
		int neighbourhood = 20;
		
		for (int accR = 0; accR < rDim; accR++) {
			for (int accPhi = 0; accPhi < phiDim; accPhi++) {
				// compute current index in the accumulator
				int idx = (accPhi + 1) * (rDim + 2) + accR + 1;
				if (accumulator[idx] > minVotes) {
					boolean bestCandidate = true;
					// iterate over the neighbourhood
					for (int dPhi = -neighbourhood / 2; dPhi < neighbourhood / 2 + 1; dPhi++) {
						// check we are not outside the image
						if (accPhi + dPhi < 0 || accPhi + dPhi >= phiDim)
							continue;
						for (int dR = -neighbourhood / 2; dR < neighbourhood / 2 + 1; dR++) {
							// check we are not outside the image
							if (accR + dR < 0 || accR + dR >= rDim)
								continue;
							int neighbourIdx = (accPhi + dPhi + 1) * (rDim + 2)
									+ accR + dR + 1;
							if (accumulator[idx] <= accumulator[neighbourIdx]) {
								// the current idx is not a local maximum!
								bestCandidate = false;
								break;
							}
						}
						if (!bestCandidate)
							break;
					}
					if (bestCandidate) {
						// the current idx *is* a local maximum
						bestCandidates.add(idx);
					}
				}
			}

		}
		// ======================================================================================

		Collections.sort(bestCandidates, comparator);
		
		ArrayList<PVector> lines = new ArrayList<PVector>();
		
		// For each pair (r, ϕ) in the accumulator that received more that 180
		// votes, plot the corresponding line on top of the image
		for (int idx = 0; idx < Math.min(bestCandidates.size(), nLines); idx++) {

			// first, compute back the (r, phi) polar coordinates:
			int accPhi = (int) (bestCandidates.get(idx) / (rDim + 2)) - 1;
			int accR = bestCandidates.get(idx) - (accPhi + 1) * (rDim + 2) - 1;
			float r = (accR - (rDim - 1) * 0.5f) * discretizationStepsR;
			float phi = accPhi * discretizationStepsPhi;

			lines.add(new PVector(r, phi));

			// Cartesian equation of a line: y = ax + b
			// in polar, y = (-cos(phi)/sin(phi))x + (r/sin(phi))
			// => y = 0 : x = r / cos(phi)
			// => x = 0 : y = r / sin(phi)
			// compute the intersection of this line with the 4 borders of
			// the image
			int x0 = 0;
			int y0 = (int) (r / sin(phi));
			int x1 = (int) (r / cos(phi));
			int y1 = 0;
			int x2 = edgeImg.width;
			int y2 = (int) (-cos(phi) / sin(phi) * x2 + r / sin(phi));
			int y3 = edgeImg.width;
			int x3 = (int) (-(y3 - r / sin(phi)) * (sin(phi) / cos(phi)));

			// Finally, plot the lines
			stroke(204, 102, 0);
			if (y0 > 0) {
				if (x1 > 0)
					line(x0, y0, x1, y1);
				else if (y2 > 0)
					line(x0, y0, x2, y2);
				else
					line(x0, y0, x3, y3);
			} else {
				if (x1 > 0) {
					if (y2 > 0)
						line(x1, y1, x2, y2);
					else
						line(x1, y1, x3, y3);
				} else
					line(x2, y2, x3, y3);
			}
		}

		return lines;
	}
	
	//====================================================================================
	// Milestone 3 : Middle image
	public PImage spectraHough(int rDim, int phiDim, int [] accumulator, PImage edgeImg) {
		
				PImage houghImg = createImage(rDim + 2, phiDim + 2, ALPHA);
				 
				for (int i = 0; i < accumulator.length; i++) { 
					houghImg.pixels[i] = color(min(255, accumulator[i])); 
				}
				 
				houghImg.updatePixels(); 
				
				return houghImg;
	}
	//=====================================================================================

	public PVector intersection(PVector line1, PVector line2) {
		
		// compute the intersection
		float d = cos(line2.y) * sin(line1.y) - cos(line1.y)
				* sin(line2.y);
		float x = (line2.x * sin(line1.y) - line1.x * sin(line2.y)) / d;
		float y = (-line2.x * cos(line1.y) + line1.x * cos(line2.y))
				/ d;
		
		return new PVector(x, y);
	}
	
	public void displayQuad(List<int[]> quads, List<PVector> lines) {
		
		for (int[] quad : quads) {
			
			PVector l1 = lines.get(quad[0]);
			PVector l2 = lines.get(quad[1]);
			PVector l3 = lines.get(quad[2]);
			PVector l4 = lines.get(quad[3]);
			
			PVector c12 = intersection(l1, l2);
			PVector c23 = intersection(l2, l3);
			PVector c34 = intersection(l3, l4);
			PVector c41 = intersection(l4, l1);
			
			//Filter the quads that are not convex, too small or non flat
			boolean isValid = (quadGraph.isConvex(c12, c23, c34, c41) && 
					quadGraph.validArea(c12, c23, c34, c41, 1000000, 50000) && quadGraph.nonFlatQuad(c12, c23, c34, c41));
			
			if(isValid) {
				// Choose a random, semi-transparent colour
				Random random = new Random();
				fill(color(min(255, random.nextInt(300)),
					min(255, random.nextInt(300)),
					min(255, random.nextInt(300)), 50));
			
				quad(c12.x, c12.y, c23.x, c23.y, c34.x, c34.y, c41.x, c41.y);
			}
		}

	}

	public PVector getRot(List<PVector> intersections, TwoDThreeD C3PO) {
		return C3PO.get3DRotations(C3PO.sortCorners(intersections));
	}
	
	// This class represents a cylinder
	class Cylinder {

		// Cylinder attributes:
		// Parameters:
		int cylinderBaseSize;
		int cylinderHeight;
		int cylinderResolution;

		// The 3 faces of the closed cylinder:
		PShape openCylinder;
		PShape topFace;
		PShape bottomFace;

		// Constructor for a new Cylinder:
		Cylinder(int cylinderBaseSize, int cylinderHeight,
				int cylinderResolution) {
			this.cylinderBaseSize = cylinderBaseSize;
			this.cylinderHeight = cylinderHeight;
			this.cylinderResolution = cylinderResolution;
			openCylinder = new PShape();
			topFace = new PShape();
			bottomFace = new PShape();

			float angle;
			float[] x = new float[cylinderResolution + 1];
			float[] y = new float[cylinderResolution + 1];

			// get the x and y position on a circle for all the sides
			for (int i = 0; i < x.length; i++) {
				angle = (TWO_PI / cylinderResolution) * i;
				x[i] = sin(angle) * cylinderBaseSize;
				y[i] = cos(angle) * cylinderBaseSize;
			}

			stroke(0);
			fill(139, 69, 19);
			// Open Cylinder:
			openCylinder = createShape();
			openCylinder.beginShape(QUAD_STRIP);
			// draw the border of the cylinder
			for (int i = 0; i < x.length; i++) {
				openCylinder.vertex(x[i], y[i], 0);
				openCylinder.vertex(x[i], y[i], cylinderHeight);
			}
			openCylinder.endShape();

			stroke(0);
			fill(238, 197, 145);
			// Top Face:
			topFace = createShape();
			topFace.beginShape(TRIANGLES);
			// draw the topFace of the closed cylinder
			for (int i = 0; i < x.length - 1; i++) {
				topFace.vertex(x[i], y[i], cylinderHeight);
				topFace.vertex(x[i + 1], y[i + 1], cylinderHeight);
				topFace.vertex(0, 0, cylinderHeight);
			}
			topFace.endShape();

			noStroke();
			fill(139, 69, 19);
			// Bottom Face
			bottomFace = createShape();
			bottomFace.beginShape(TRIANGLES);
			// draw the bottomFace of the closed cylinder
			for (int i = 0; i < x.length - 1; i++) {
				bottomFace.vertex(x[i], y[i], 0);
				bottomFace.vertex(x[i + 1], y[i + 1], 0);
				bottomFace.vertex(0, 0, 0);
			}
			bottomFace.endShape();

		}

		public void display(float x, float y, int boxDepth) {
			pushMatrix();
			// rotate the cylinder to obtain view from the top
			rotateX(PI / 2);
			// follow the mouse
			translate(x, y, boxDepth / 2);
			// display the shapes
			shape(openCylinder);
			shape(topFace);
			shape(bottomFace);
			popMatrix();
		}

	}

	// This class represents a mover for the Ball
	class Mover {

		// Mover attributes:
		// Ball attributes:
		PVector location;
		PVector velocity;
		int sphereRadius;

		// Forces & parameters:
		PVector gravity;
		PVector friction;
		PVector totalForce;
		float g = 0.581f;
		float normalForce;
		float mu;
		float frictionMagnitude;
		float elasticity;

		// Score parameters:
		float score;
		float lastScore;

		// Constructor for a new Mover
		Mover(int boxDepth, int sphereRadius) {
			location = new PVector(0, -(boxDepth / 2 + sphereRadius), 0);
			velocity = new PVector(0, 0, 0);
			this.sphereRadius = sphereRadius;
			gravity = new PVector(0, 0, 0);
			totalForce = new PVector(0, 0, 0);
			normalForce = 1;
			mu = 0.01f;
			frictionMagnitude = normalForce * mu;
			elasticity = 0.8f;
			
			score = 0.0f;
			lastScore = 0.0f;
		}

		// Getter for x coordinate
		public float getX() {
			return location.x;
		}

		// Getter for z coordinate
		public float getZ() {
			return location.z;
		}

		// Getter for X velocity
		public float getVelocityX() {
			return velocity.x;
		}

		// Getter for Z velocity
		public float getVelocityZ() {
			return velocity.z;
		}

		// Getter for the velocity magnitude
		public float getVelocityMagnitude() {
			return velocity.mag();
		}

		// Getter for current total score
		public float getScore() {
			return score;
		}

		// Getter for last score (last hitting event)
		public float getLastScore() {
			return lastScore;
		}

		// Update the velocity & location according to the total force exerted
		// on the ball
		public void update(float x, float z) {
			updateForces(x, z);
			velocity.add(totalForce);
			location.add(velocity);
		}

		// Update the forces according to the plate position
		public void updateForces(float x, float z) {
			gravity.x = sin(z) * g;
			gravity.z = sin(-x) * g;
			friction = velocity.get();
			friction.mult(-1);
			friction.normalize();
			friction.mult(frictionMagnitude);
			totalForce = friction.get();
			totalForce.add(gravity);
		}

		// Display the ball on the plate
		public void display() {
			pushMatrix();
			noStroke();
			fill(139, 10, 80);
			sphere(sphereRadius);
			popMatrix();
		}

		// Check if the ball is on the edges of the plate
		public void checkEdges(int boxLength) {
			if (location.x >= (boxLength / 2.0f)) {
				lastScore = -velocity.mag();
				score -= velocity.mag();
				if (score < 0.0f) {
					score = 0.0f;
				}
				velocity.x = velocity.x * -elasticity;
				location.x = (boxLength / 2.0f);
			} else if (location.x <= -(boxLength / 2.0f)) {
				lastScore = -velocity.mag();
				score -= velocity.mag();
				if (score < 0.0f) {
					score = 0.0f;
				}
				velocity.x = velocity.x * (-elasticity);
				location.x = -(boxLength / 2.0f);
			}
			if (location.z >= (boxLength / 2.0f)) {
				lastScore = -velocity.mag();
				score -= velocity.mag();
				if (score < 0.0f) {
					score = 0.0f;
				}
				velocity.z = velocity.z * (-elasticity);
				location.z = (boxLength / 2.0f);
			} else if (location.z <= -(boxLength / 2.0f)) {
				lastScore = -velocity.mag();
				score -= velocity.mag();
				if (score < 0.0f) {
					score = 0.0f;
				}
				velocity.z = velocity.z * (-elasticity);
				location.z = -(boxLength / 2.0f);
			}
		}

		// Check if the ball hits a cylinder
		public void checkCylinderCollision(ArrayList<PVector> a,
				int cylinderBaseSize, int boxDepth) {
			for (PVector c : a) {
				// Create a new cylinder vector adapted to the location
				PVector correctedC = new PVector(c.x, location.y, c.y);
				if (correctedC.dist(location) <= (sphereRadius + cylinderBaseSize)) {
					// Increment the score by current velocity & save the last
					// score (last hitting event)
					lastScore = velocity.mag();
					score += velocity.mag();
					// Compute the normal vector
					PVector normal = correctedC.get();
					normal.sub(location);
					normal.normalize();
					// Compute the new correct location
					PVector updatedLocation = normal.get();
					updatedLocation.mult(-(cylinderBaseSize + sphereRadius));
					updatedLocation.add(correctedC);
					location = new PVector(updatedLocation.x,
							-(boxDepth / 2 + sphereRadius), updatedLocation.z); // to
																				// avoid
																				// enter
																				// the
																				// cylinder
																				// we
																				// update
																				// the
																				// location
					// Update the velocity
					normal.mult(2 * velocity.dot(normal));
					velocity.sub(normal);
					velocity.mult(elasticity);
				}
			}
		}

	}

	static public void main(String[] passedArgs) {
		String[] appletArgs = new String[] { "--full-screen",
				"--bgcolor=#666666", "--stop-color=#cccccc", "Game" };
		if (passedArgs != null) {
			PApplet.main(concat(appletArgs, passedArgs));
		} else {
			PApplet.main(appletArgs);
		}
	}
}
