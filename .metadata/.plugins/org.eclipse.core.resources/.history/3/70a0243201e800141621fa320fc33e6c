package cs211;

import processing.core.PApplet;
import processing.core.PImage;

public class ImageProcessing extends PApplet {
	PImage img;
	int threshold;
	HScrollbar thresholdBar;
	
	public void setup() {
			size(800, 600);
			img = loadImage("board1.jpg");
//			threshold = 128;
			thresholdBar = new HScrollbar(this, 0, 580, 800, 20);
//			noLoop(); // no interactive behaviour: draw() will be called only once.
	}
	
	public void draw() {
			background(color(0,0,0));
			
			image(colourThr(img), 0, 0);
			
			thresholdBar.display();
			thresholdBar.update();
			
			threshold = (int) (255 * thresholdBar.getPos());
	}
	
	public PImage binaryFilter(PImage img) {
		PImage result = createImage(width, height, RGB); // create a new, initially transparent, 'result' image
		for(int i = 0; i < img.width * img.height; i++) {
			// do something with the pixel img.pixels[i]
			float currentBrightness = brightness(img.pixels[i]);
			if(currentBrightness > threshold) {
				result.pixels[i] = color(255);
			} else {
				result.pixels[i] = color(0);
			}
		}
		return result;
	}
	
	public PImage InvertedBinaryFilter(PImage img) {
		PImage result = createImage(width, height, RGB); // create a new, initially transparent, 'result' image
		for(int i = 0; i < img.width * img.height; i++) {
			// do something with the pixel img.pixels[i]
			float currentBrightness = brightness(img.pixels[i]);
			if(currentBrightness <= threshold) {
				result.pixels[i] = color(255, 120, 50);
			} else {
				result.pixels[i] = color(0);
			}
		}
		return result;
	}
	
	public PImage colourThr(PImage img) { 
		PImage hueMap = createImage(width, height, RGB); // create a new, initially transparent, 'result' image
		colorMode(HSB, 255);
		for(int i = 0; i < img.width * img.height; i++) {
			float currentHue = hue((int) img.pixels[i]);
			hueMap.pixels[i] = (int) currentHue;
		}
		return hueMap;
	}
	
}